<!-- title: java 基础 --> 

# 常用概念区分

## 进程和线程
**进程：** 进程是系统进行资源分配和调度的一个独立单位；
**线程：** 线程是进程的一个实体，是CPU调度和分派的基本单位，一个进程中的多个线程共享大部分系统资源，除了程序计数器，寄存器和栈；

# java常见面试题
## HashMap常见面试题：
[Java集合框架常见面试题]https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java集合框架常见面试题.md#145-hashmap-的底层实现)
1. HashMap的底层数据结构？
   
   hashmap是底层是由数组和链表构成的，每个数组的中的值是一个链表，链表中的值java8之前叫entry，之后叫node，每个值里面包含4个成员变量;
   ```java
   static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
    ```
2. HashMap的存取原理？

    [HashMap存取原理之JDK8](https://www.cnblogs.com/lijinshan950823/p/9476569.html)

    简单来讲：hashMap接收到一个新的值后先对值取hash，根据数组长度分配到不同的buckets中，如果分配的bucket中有已经有值，判断新的对象的key与bucket中的值是否相等，不相等直接插入链尾，相等就覆盖；
    链表转红黑树的问题，当链表长度大于8而且map整体元素个数大于64的时候，jdk8会将链表转化成红黑树以减少搜索时间；
    数组扩容：当集合中对象个数超过容量的一定比例`DEFAULT_LOAD_FACTOR=0.75l`时候开始进行扩容，集合容器默认大小为16， 最大为`1<<30`

3. Java7和Java8的区别？
4. 为啥会线程不安全？

    jdk8之前多线程插入会造成循环链表和数据丢失的问题，jdk8之后使用尾链法避免了循环链表但还是会出现当两个对象同时分配到同一个bucket的时候数据可能会被覆盖

5. 有什么线程安全的类代替么?

    `Hashtable` 和 `ConcurrentHashMap`, `Hashtable`采用的整体加锁，每次put操作需要先获取锁；`ConcurrentHashMap`jdk8之前采用分段锁，jdk8之后采用的是节点锁
6. 默认初始化大小是多少？为啥是这么多？为啥大小都是2的幂？

    集合容器默认大小为16， 最大为`1<<30`， 2的幂是为了实现**均匀分布**。
    为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。

    这个算法应该如何设计呢？

    我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。

7. HashMap的扩容方式？负载因子是多少？为什是这么多？

    当集合中对象个数超过容量的一定比例`DEFAULT_LOAD_FACTOR=0.75l`时候开始进行扩容，
8. HashMap的主要参数都有哪些？
9. HashMap是怎么处理hash碰撞的？
10. hash的计算规则？
11. 为什么重写equals方法必须冲洗hashCode方法?

    如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

12. 初始化时给hashmap的初始容量赋值，当我们明确知道HashMap中元素的个数的时候，把默认值设为： `expectSize / 0.75F + 1`