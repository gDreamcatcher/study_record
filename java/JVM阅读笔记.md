# 深入理解Java虚拟机

[TOC]



## 自动内存管理机制

### 运行时数据区域

**程序计数器：** 内存空间小，线程私有， 可以看作是当前线程所执行的字节码的行号指示器，是唯一一个不会触发OutofMemoryError的区域。

**java虚拟机栈：** 线程私有，用于存储局部变量表，操作数栈，动态链接和方法出口等信息。局部变量表存储一些编译期可知的各种基本数据类型、对象引用和returnAddress类型。有可能抛出StackOverflowError和OutOfMemoryError。

**本地方法栈：** 线程私有，为虚拟机使用到的Native方法服务，有可能跑出StackOverflowError和OutOfMemoryError。

**Java堆：** 线程共享，虚拟机启动时候创建，所有的对象实例都是在堆上分配(栈上分配和标量替换优化技术导致不是所有对象都是在堆上分配)。当堆无法申请出新的内存时候会抛出OutOfMemoryError。

**方法区：** 线程共享，存储虚拟机加载的类信息、常量、静态变量、及时编译后的代码等数据。

**运行时常量池：** 方法区的一部分，存放编译期生成的各种字面量和符号引用， 可动态扩展例如String的intern()方法。

**直接内存：** JDK1.4后引入的NIO，使用Native函数直接分配堆外内存，然后通过DirectByteBuffer对象直接使用这块内存，避免了在Java堆和Native堆中来回复制数据，大大提升了性能。



### 虚拟机对象生命周期

#### 对象的创建

虚拟机创建对象前会检查这个指令的参数是否可以在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析和初始化过，如果没有则必须先执行相应的类加载过程。

```flow
st=>start: New对象
e=>end: End
op1=>operation: 类加载检查
op2=>operation: 分配内存

st(right)->op1(right)->op2(right)->e
```

#### 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头(header)，实例数据(instace data)和对其填充(padding)。

**对象头：** 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据如哈希码等；第二部分是类型指针，即对象指向它类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。

**实例数据：** 存储对象的成员方法和成员变量。

**对齐填充：** 占位符，使每个对象内存大小都是8字节的整数倍

#### 对象的访问定位

**使用句柄：** 使用句柄来访问的最大好处就是reference中存储的稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。

**直接指针：** 最大的好处是速度快。